package com.github.kropp.jsonex

import java.io.File
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.TypeElement
import javax.lang.model.type.ArrayType
import javax.lang.model.type.TypeKind
import javax.lang.model.type.TypeMirror


@SupportedAnnotationTypes("com.github.kropp.jsonex.Json")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class JsonAnnotationProcessor : AbstractProcessor() {
  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
    val elements = annotations.filter { it.qualifiedName.contentEquals("com.github.kropp.jsonex.Json") }
        .map { roundEnv.getElementsAnnotatedWith(it) }
        .flatMap { it }
        .filterIsInstance<TypeElement>()

    if (elements.any()) {
      File(kotlinGenerated).mkdirs()
      elements.forEach {
        generateMutableInterface(it, elements.map { it.qualifiedName.toString() })
      }
    }

    return true
  }

  private val kotlinGenerated by lazy { processingEnv.options["kapt.kotlin.generated"] }

  private fun propName(element: Element): String {
    val name = element.simpleName.removePrefix("get")
    return name[0].toLowerCase() + name.substring(1)
  }

  private fun typeName(type: TypeMirror): String = when(type.kind) {
    TypeKind.BOOLEAN -> "Boolean"
    TypeKind.BYTE -> "Byte"
    TypeKind.SHORT -> "Short"
    TypeKind.INT -> "Int"
    TypeKind.LONG -> "Long"
    TypeKind.CHAR -> "Char"
    TypeKind.FLOAT -> "Float"
    TypeKind.DOUBLE -> "Double"
    TypeKind.VOID -> "Unit"
    TypeKind.ARRAY -> "Array<out ${typeName((type as ArrayType).componentType).removePrefix("Mutable")}>"
    TypeKind.DECLARED -> {
      val typeName = type.toString()
      when (typeName) {
        "java.lang.String" -> "String"
        "java.util.Date" -> typeName
        else -> "Mutable" + typeName
      }
    }
    else -> ""
  }

  private fun helperName(type: TypeMirror): String = when(type.kind) {
    TypeKind.BOOLEAN -> "bool()"
    TypeKind.BYTE, TypeKind.SHORT, TypeKind.INT, TypeKind.LONG -> "int()"
    TypeKind.CHAR -> "string()"
    TypeKind.FLOAT, TypeKind.DOUBLE -> "double()"
    TypeKind.ARRAY -> "array<${typeName((type as ArrayType).componentType).removePrefix("Mutable")}>()"
    TypeKind.DECLARED -> {
      val typeName = type.toString()
      when (typeName) {
        "java.lang.String" -> "string()"
        "java.util.Date" -> "date()"
        else -> typeName + "Impl()"
      }
    }
    else -> ""
  }

  private fun generateMutableInterface(element: TypeElement, elements: List<String>) {
    val className = element.simpleName
    File(kotlinGenerated, "${className}Json.kt").writer().buffered().use {
      if (element.qualifiedName != element.simpleName) {
        it.appendln("package ${element.qualifiedName.removeSuffix("." + element.simpleName)}")
      }
      it.appendln("import com.github.kropp.jsonex.*")

      it.appendln("interface Mutable$className {")
      for (property in element.enclosedElements.filterIsInstance<ExecutableElement>()) {
        val propName = propName(property)
        val typeName = typeName(property.returnType)

        it.appendln("  var $propName: $typeName")
        if (typeName in elements) {
          it.appendln("  fun $propName(builder: $typeName.() -> Unit) = $propName.apply(builder)")
        }
      }
      it.appendln("}")

      it.appendln("class ${className}Impl(map: Map<String,Any> = mapOf()) : $className, JsonObject<${className}Impl>(map) {")
      for (property in element.enclosedElements.filterIsInstance<ExecutableElement>()) {
        val propName = propName(property)
        val helperName = helperName(property.returnType)

        it.appendln("  override val $propName by $helperName")
      }
      it.appendln("}")
    }
  }
}