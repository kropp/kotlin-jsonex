package com.github.kropp.jsonex

import java.io.File
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.TypeElement
import javax.lang.model.type.ArrayType
import javax.lang.model.type.TypeKind
import javax.lang.model.type.TypeMirror


@SupportedAnnotationTypes("com.github.kropp.jsonex.Json")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class JsonAnnotationProcessor : AbstractProcessor() {
  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
    val elements = annotations.filter { it.qualifiedName.contentEquals("com.github.kropp.jsonex.Json") }
        .map { roundEnv.getElementsAnnotatedWith(it) }
        .flatMap { it }

    if (elements.any()) {
      File(kotlinGenerated).mkdirs()
      elements.forEach {
        generateMutableInterface(it, elements.filterIsInstance<TypeElement>().map { it.qualifiedName.toString() })
      }
    }

    return true
  }

  private val kotlinGenerated by lazy { processingEnv.options["kapt.kotlin.generated"] }

  private fun propName(element: Element): String {
    val name = element.simpleName.removePrefix("get")
    return name[0].toLowerCase() + name.substring(1)
  }

  private fun typeName(type: TypeMirror): String = when(type.kind) {
    TypeKind.BOOLEAN -> "Boolean"
    TypeKind.BYTE -> "Byte"
    TypeKind.SHORT -> "Short"
    TypeKind.INT -> "Int"
    TypeKind.LONG -> "Long"
    TypeKind.CHAR -> "Char"
    TypeKind.FLOAT -> "Float"
    TypeKind.DOUBLE -> "Double"
    TypeKind.VOID -> "Unit"
    TypeKind.ARRAY -> "Array<${typeName((type as ArrayType).componentType)}>"
    TypeKind.DECLARED -> {
      val typeName = type.toString()
      if (typeName == "java.lang.String") "String" else typeName
    }
    else -> ""
  }

  private fun generateMutableInterface(element: Element, elements: List<String>) {
    File(kotlinGenerated, "Mutable${element.simpleName}.kt").writer().buffered().use {
      it.appendln("interface Mutable${element.simpleName} {")
      for (property in element.enclosedElements.filterIsInstance<ExecutableElement>()) {
        val propName = propName(property)
        val typeName = typeName(property.returnType)

        it.appendln("  var $propName: $typeName")
        if (typeName in elements) {
          it.appendln("  fun $propName(builder: ${typeName}Builder.() -> Unit) = $propName.apply(builder)")
        }
      }
      it.appendln("}")
    }
  }
}