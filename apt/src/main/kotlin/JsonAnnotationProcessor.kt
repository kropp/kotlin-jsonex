package com.github.kropp.jsonex

import java.io.File
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.TypeElement
import javax.lang.model.type.ArrayType
import javax.lang.model.type.DeclaredType
import javax.lang.model.type.TypeKind
import javax.lang.model.type.TypeMirror


@SupportedAnnotationTypes("com.github.kropp.jsonex.Json")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class JsonAnnotationProcessor : AbstractProcessor() {
  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
    val elements = annotations.filter { it.qualifiedName.contentEquals("com.github.kropp.jsonex.Json") }
        .map { roundEnv.getElementsAnnotatedWith(it) }
        .flatMap { it }
        .filterIsInstance<TypeElement>()

    if (elements.any()) {
      File(kotlinGenerated).mkdirs()
      elements.forEach {
        generateMutableInterface(it, elements.map { it.qualifiedName.toString() })
      }
    }

    return true
  }

  private val kotlinGenerated by lazy { processingEnv.options["kapt.kotlin.generated"] }

  private fun firstToLower(name: CharSequence) = name[0].toLowerCase() + name.substring(1)

  private fun propName(element: Element) = firstToLower(element.simpleName.removePrefix("get"))

  private fun typeName(type: TypeMirror): String = when(type.kind) {
    TypeKind.BOOLEAN -> "Boolean"
    TypeKind.BYTE -> "Byte"
    TypeKind.SHORT -> "Short"
    TypeKind.INT -> "Int"
    TypeKind.LONG -> "Long"
    TypeKind.CHAR -> "Char"
    TypeKind.FLOAT -> "Float"
    TypeKind.DOUBLE -> "Double"
    TypeKind.VOID -> "Unit"
    TypeKind.ARRAY -> "Array<out ${typeName((type as ArrayType).componentType)}>"
    TypeKind.DECLARED -> {
      val typeName = type.toString()
      when (typeName) {
        "java.lang.String" -> "String"
        else -> typeName
      }
    }
    else -> ""
  }

  private fun mutableTypeName(type: TypeMirror): String = when(type.kind) {
    TypeKind.DECLARED -> {
      val typeName = type.toString()
      when (typeName) {
        "java.lang.String" -> "String"
        "java.util.Date" -> typeName
        else -> {
          val element = (type as DeclaredType).asElement()
          val packageName = element.toString().removeSuffix(element.simpleName)

          packageName + "Mutable" + element.simpleName
        }
      }
    }
    else -> typeName(type)
  }

  private fun helperName(type: TypeMirror): String = when(type.kind) {
    TypeKind.BOOLEAN -> "bool()"
    TypeKind.BYTE, TypeKind.SHORT, TypeKind.INT, TypeKind.LONG -> "int()"
    TypeKind.CHAR -> "string()"
    TypeKind.FLOAT, TypeKind.DOUBLE -> "double()"
    TypeKind.ARRAY -> "array<${typeName((type as ArrayType).componentType).removePrefix("Mutable")}>()"
    TypeKind.DECLARED -> {
      val typeName = type.toString()
      when (typeName) {
        "java.lang.String" -> "string()"
        "java.util.Date" -> "date()"
        else -> typeName + "Impl()"
      }
    }
    else -> ""
  }

  private fun mutableHelperName(type: TypeMirror): String = when(type.kind) {
    TypeKind.BOOLEAN -> "bool()"
    TypeKind.BYTE, TypeKind.SHORT, TypeKind.INT, TypeKind.LONG -> "int()"
    TypeKind.CHAR -> "string()"
    TypeKind.FLOAT, TypeKind.DOUBLE -> "double()"
    TypeKind.ARRAY -> "array<${typeName((type as ArrayType).componentType).removePrefix("Mutable")}>()"
    TypeKind.DECLARED -> {
      val typeName = type.toString()
      when (typeName) {
        "java.lang.String" -> "string()"
        "java.util.Date" -> "date()"
        else -> {
          val element = (type as DeclaredType).asElement()
          val packageName = element.toString().removeSuffix(element.simpleName)

          "${packageName}Mutable${element.simpleName}Impl()"
        }
      }
    }
    else -> ""
  }

  private fun generateMutableInterface(element: TypeElement, elements: List<String>) {
    val className = element.simpleName
    File(kotlinGenerated, "${className}Json.kt").writer().buffered().use {
      if (element.qualifiedName != element.simpleName) {
        it.appendln("package ${element.qualifiedName.removeSuffix("." + element.simpleName)}")
      }
      it.appendln("import com.github.kropp.jsonex.*")

      it.appendln("interface Mutable$className {")
      for (property in element.enclosedElements.filterIsInstance<ExecutableElement>()) {
        val propName = propName(property)
        val typeName = mutableTypeName(property.returnType)

        it.appendln("  var $propName: $typeName")
        if (property.returnType.toString() in elements) {
          it.appendln("  fun $propName(builder: $typeName.() -> Unit) = $propName.apply(builder)")
        }
      }
      it.appendln("}")

      it.appendln("class ${className}Impl(map: Map<String,Any> = mapOf()) : $className, JsonObject<${className}Impl>(map) {")
      for (property in element.enclosedElements.filterIsInstance<ExecutableElement>()) {
        val propName = propName(property)
        val helperName = helperName(property.returnType)

        it.appendln("  override val $propName by $helperName")
      }
      it.appendln("}")

      it.appendln("class Mutable${className}Impl(map: MutableMap<String,Any> = mutableMapOf()) : Mutable$className, JsonObjectBuilder<Mutable${className}Impl, Mutable$className>(map) {")
      for (property in element.enclosedElements.filterIsInstance<ExecutableElement>()) {
        val propName = propName(property)
        val helperName = mutableHelperName(property.returnType)

        it.appendln("  override var $propName: ${mutableTypeName(property.returnType)} by $helperName")
      }
      it.appendln("}")

      it.appendln("fun ${firstToLower(className)}(builder: Mutable$className.() -> Unit): $className = ${className}Impl(Mutable${className}Impl().apply(builder)._map)")
    }
  }
}